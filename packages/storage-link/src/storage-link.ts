import { SecureContextConfig } from './interfaces'
import { DIDClient } from "@verida/did-client"
import { DIDDocument, Interfaces } from "@verida/did-document"
import { DIDDocument as DocInterface, ServiceEndpoint } from 'did-resolver'
const Url = require('url-parse')

/**
 * Class representing the link between a DID and Storage context
 */
export default class StorageLink {

    // @todo: cache
    static async getLinks(didClient: DIDClient, did: string): Promise<SecureContextConfig[]> {
        if (!did) {
            return []
        }

        const didDocument = await didClient.get(did)
        if (!didDocument) {
            return []
        }

        return StorageLink.buildSecureContexts(didDocument)
    }

    /**
     * 
     * @param didClient 
     * @param did 
     * @param contextName 
     * @returns SecureStorageContextConfig | undefined (if not found)
     */
    static async getLink(didClient: DIDClient, did: string, context: string, contextIsName: boolean = true): Promise<SecureContextConfig | undefined> {
        let contextHash = context
        if (contextIsName) {
            contextHash = DIDDocument.generateContextHash(did, context)
        }

        const secureContexts =  await StorageLink.getLinks(didClient, did)
        const secureContext = StorageLink._findHash(secureContexts, contextHash)

        return secureContext
    }

    /**
     * 
     * @param didClient
     * @param storageConfig (Must have .id as the contextName)
     */
    static async setLink(didClient: DIDClient, storageConfig: SecureContextConfig) {
        const did = didClient.getDid()

        if (!did) {
            throw new Error("DID client is not authenticated")
        }

        let didDocument = await didClient.get(did)

        // Create a new DID document if it doesn't already exist
        if (didDocument.export().verificationMethod!.length <= 1) {
            // If we only have a single verification method, that indicates the DID Document was
            // auto-generated by the DID resolver, rather than fetching an existing document
            // from the blockchain. As such, we need to create a DID document and ensure we
            // provide a public key which is needed to be saved so data signed by the DID private
            // key can be verified off chain (ie: when connecting to a data storage node)
            didDocument = new DIDDocument(did, didClient.getPublicKey())
        } else {
            // Remove existing context if it exists
            const existing = await StorageLink.getLink(didClient, did, storageConfig.id)
            if (existing) {
                await StorageLink.unlink(didClient, storageConfig.id)
            }
        }

        // Build context hash in the correct format
        const contextHash = DIDDocument.generateContextHash(did, storageConfig.id)

        // Add services
        didDocument.addContextService(contextHash, Interfaces.EndpointType.DATABASE, storageConfig.services.databaseServer.type, StorageLink.standardizeUrl(storageConfig.services.databaseServer.endpointUri))
        didDocument.addContextService(contextHash, Interfaces.EndpointType.MESSAGING, storageConfig.services.messageServer.type, StorageLink.standardizeUrl(storageConfig.services.messageServer.endpointUri))

        if (storageConfig.services.storageServer) {
            didDocument.addContextService(contextHash, Interfaces.EndpointType.STORAGE, storageConfig.services.storageServer!.type, StorageLink.standardizeUrl(storageConfig.services.storageServer!.endpointUri))
        }

        if (storageConfig.services.notificationServer) {
            didDocument.addContextService(contextHash, Interfaces.EndpointType.NOTIFICATION, storageConfig.services.notificationServer!.type, StorageLink.standardizeUrl(storageConfig.services.notificationServer!.endpointUri))
        }

        // Add keys
        didDocument.addContextSignKey(contextHash, storageConfig.publicKeys.signKey.publicKeyHex)
        didDocument.addContextAsymKey(contextHash, storageConfig.publicKeys.asymKey.publicKeyHex)

        return await didClient.save(didDocument)
    }

    static async setContextService(didClient: DIDClient, contextName: string, endpointType: Interfaces.EndpointType, serverType: string, endpointUri: string): Promise<boolean> {
        const did = didClient.getDid()
        if (!did) {
            throw new Error("DID client is not authenticated")
        }

        // Fetch existing DID document
        const didDocument = await didClient.get(did)
        if (!didDocument) {
            throw new Error(`DID Document doesn't exist for this context`)
        }

        // Build context hash in the correct format
        const contextHash = DIDDocument.generateContextHash(did, contextName)

        // Add the context service
        await didDocument.addContextService(contextHash, endpointType, serverType, StorageLink.standardizeUrl(endpointUri))

        return await didClient.save(didDocument)
    }

    static async unlink(didClient: DIDClient, contextName: string): Promise<boolean> {
        const did = didClient.getDid()
        if (!did) {
            throw  new Error("DID Client is not authenticated")
        }

        const didDocument = await didClient.get(did)
        if (!didDocument) {
            return false
        }

        const success = await didDocument!.removeContext(contextName)
        if (!success) {
            return false
        }

        return await didClient.save(didDocument)
    }

    static _findHash(contexts: any[], hash: string): SecureContextConfig | undefined {
        for (let i in contexts) {
            if (contexts[i].id == hash) {
                return contexts[i]
            }
        }
    }

    static buildSecureContexts(didDocument: DIDDocument): SecureContextConfig[] {
        const doc: DocInterface = didDocument.export()
        const did = doc.id

        // strategy: loop through all signing keys as our way of looping through all contexts
        const contexts: SecureContextConfig[] = []
        doc.keyAgreement?.map((value: any) => {
            const assertionParts = Url(value, true)
            if (!assertionParts.query || !assertionParts.query.context) {
                return
            }

            const contextHash = assertionParts.query.context
            
            // Get signing key
            const signKeyVerificationMethod = doc.verificationMethod!.find((entry: any) => entry.id == `${did}?context=${contextHash}&type=sign`)
            if (!signKeyVerificationMethod) {
                return
            }

            const signKey = signKeyVerificationMethod!.publicKeyHex

            // Get asym key
            const asymKeyVerificationMethod = doc.verificationMethod!.find((entry: any) => entry.id == `${did}?context=${contextHash}&type=asym`)
            if (!asymKeyVerificationMethod)  {
                return 
            }

            const asymKey = asymKeyVerificationMethod!.publicKeyHex

            // Get services
            const databaseService = doc.service!.find((entry: any) => entry.id == `${did}?context=${contextHash}&type=database`)
            const messageService = doc.service!.find((entry: any) => entry.id == `${did}?context=${contextHash}&type=messaging`)
            const storageService = doc.service!.find((entry: any) => entry.id == `${did}?context=${contextHash}&type=storage`)
            const notificationService = doc.service!.find((entry: any) => entry.id == `${did}?context=${contextHash}&type=notification`)

            // Valid we have everything
            if (!signKey || !asymKey || !databaseService || !messageService) {
                return
            }

            // Build complete config
            const config: SecureContextConfig = {
                id: contextHash,
                publicKeys: {
                    signKey: {
                        type: "EcdsaSecp256k1VerificationKey2019",
                        publicKeyHex: `0x${signKey!}`
                    },
                    asymKey: {
                        type: "Curve25519EncryptionPublicKey",
                        publicKeyHex: `0x${asymKey!}`
                    }
                },
                services: {
                    databaseServer: {
                        type: databaseService!.type,
                        endpointUri: StorageLink.standardizeUrl(databaseService!.serviceEndpoint)
                    },
                    messageServer: {
                        type: messageService!.type,
                        endpointUri: StorageLink.standardizeUrl(messageService!.serviceEndpoint)
                    }
                }
            }

            if (storageService) {
                config.services.storageServer = {
                    type: storageService!.type,
                    endpointUri: StorageLink.standardizeUrl(storageService!.serviceEndpoint)
                }
            }

            if (notificationService) {
                config.services.notificationServer = {
                    type: notificationService!.type,
                    endpointUri: StorageLink.standardizeUrl(notificationService!.serviceEndpoint)
                }
            }

            contexts.push(config)
        })

        return contexts
    }

    /**
     * Ensure the URL has a trailing slash
     * 
     * @param endpoint ServiceEndpoint | ServiceEndpoint[]
     * @returns 
     */
    public static standardizeUrl(endpoint: ServiceEndpoint | ServiceEndpoint[]): string {
        if (typeof(endpoint) == 'string') {
            return <ServiceEndpoint> endpoint.replace(/\/$/, '') + '/'
        }

        throw new Error('Non-string service endpoints are not currently supported')
    }

}