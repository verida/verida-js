// Functions to compare objects
import { DIDDocument } from 'did-resolver'
import { BulkDelegateParam, BulkAttributeParam, DelegateTypes } from '@verida/vda-did'
import { verificationMethodTypes, interpretIdentifier } from '@verida/vda-did-resolver'

export function deepEqual(object1: any, object2:any) {
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (const key of keys1) {
        const val1 = object1[key];
        const val2 = object2[key];
        const areObjects = isObject(val1) && isObject(val2);
        if (
        areObjects && !deepEqual(val1, val2) ||
        !areObjects && val1 !== val2
        ) {
        return false;
        }
    }
    return true;
}

export function isObject(object: any) {
    return object != null && typeof object === 'object';
}

export function compareKeys(a: Object, b: Object) {
    const aKeys = Object.keys(a).sort()
    const bKeys = Object.keys(b).sort()

    return JSON.stringify(aKeys) === JSON.stringify(bKeys)
}

export function removeCommonItems(orgDoc: DIDDocument, document: DIDDocument) {
    // Remove common itesm first
    // orgDoc.verificationMethod?.forEach((item, index, arr) => {
    //     const docIndex = document?.verificationMethod?.findIndex(t => this.deepEqual(item, t))
    //     if (docIndex && docIndex !== -1 ) {
    //         // Found same object. Delete on both objects.
    //         arr.splice(index, 1)
    //         document?.verificationMethod?.splice(docIndex, 1)
    //     }
    // })
    const keys = Object.keys(orgDoc);
    keys.forEach(key => {
        if (key in <DIDDocument>document && isObject((orgDoc as any)[key])) {
            (orgDoc as any)[key].array.forEach((item : any, index: number, arr: any) => {
                const docIndex = ((document as any)[key].findIndex((t: any) => deepEqual(item, t)))
                if(docIndex && docIndex !== -1) {
                    arr.splice(index, 1)
                    ((document as any)[key]).splice(docIndex, 1)
                }
            });
        }
    });
}

export function getUpdateListFromDocument(document: DIDDocument) {
    const delegateList : BulkDelegateParam[] = []
    const attributeList : BulkAttributeParam[] = [] 

    // Process delegates & attributes
    document?.verificationMethod?.forEach(item => {
        // DIDDelegateChanged for veriKey
        // or Controller
        const {address: did} = interpretIdentifier(item.id)
        if ('blockchainAccountId' in item) {
            if (item.id.endsWith('#controller')) {
                //Controller --> publicKey
                // No need to update this. Auto generated by resolver
            } else {
                // DIDDelegate Changed --> pks
                delegateList.push({
                    delegate: did, // convert it to did
                    delegateType: DelegateTypes.veriKey
                })

            }
        } else {
            // Meaning AttributeChanged of 'pub' type --> pk
            // did/pub/<key algorithm>/<key purpose>/<encoding>

            let algorithm = 'Secp256k1'
            if (item.type === verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020 || 
                item.type === verificationMethodTypes.EcdsaSecp256k1VerificationKey2019) {
                algorithm = 'Secp256k1'
            } else if (item.type === verificationMethodTypes.Ed25519VerificationKey2018) {
                algorithm = 'Ed25519'
            } else if (item.type === verificationMethodTypes.RSAVerificationKey2018) {
                algorithm = 'Rsa'
            } else if (item.type === verificationMethodTypes.X25519KeyAgreementKey2019) {
                algorithm = 'X25519'
            }

            let keyPurpose = 'veriKey';
            if (document.authentication?.find(authItem => authItem === item.id)) {
                // meaning sigAuth attribute
                keyPurpose = 'sigAuth'
            } else if (document.keyAgreement?.find(keyrefItem => keyrefItem === item.id)) {
                // meaning enc attribute
                keyPurpose = 'enc'
            }
            
            let value = ''
            let encoding = null
            if ('publicKeyHex' in item) {
                encoding  = 'hex'
                value = item.publicKeyHex!
            } else if ('publicKeyBase64' in item) {
                encoding = 'base64'
                value = (item as any).publicKeyBase58
            } else if ('publicKeyBase58' in item) {
                encoding = 'base58'
                value = item.publicKeyBase58!
            } else if ('publicKeyPem' in item) {
                encoding = 'pem'
                value = (item as any).publicKeyPem
            } else if ('value' in item) {
                value = (item as any).value
            }

            const idMatch = item.id.match(/(.*)\?context=(\w+)/)
            const context = idMatch?.[2]
            if (context)
                value = `${value}##${context}`

            const name = `did/pub/${algorithm}/${keyPurpose}/${encoding}`

            // call revokeAttribute & setAttribute for updates
            attributeList.push({
                name,
                value
            })
        }
    })
    // Process services
    document?.service?.forEach(serviceItem => {
        // did/svc/serviceName
        // name = 'did/svc/VeridaMessage'
        // value = serviceEndPoint + '##' + context + '##messaging', 
        
        const idMatch = serviceItem.id.match(/(.*)?context=(\w+)#(\w+)/)
        const context = idMatch?.[2]
        const suffix = idMatch?.[3]

        const name = `did/svc/${serviceItem.type}`
        const value = `${serviceItem.serviceEndpoint}##${context}##${suffix}`
        
        attributeList.push({
            name,
            value
        })
    })

    return {delegateList, attributeList}
}